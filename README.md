## Лабораторная работа №2: Проверка принадлежности точек прямоугольникам

### Описание проекта

**Язык программирования:** Go (golang) 1.22.2

**Фреймворк:** go-echarts

### Структура проекта

- **genral:** Пакет с необходимыми для проекта функциями и типами
  - **generalfuncs.go:** Общие для всех алгоритмов функции
  - **generaltypes.go:** Общие структуры и методы для выполнения работы
- **solutions:** Пакет для запуска реализаций
  - brute.go: Реализация решения в лоб
  - compress.go: Реализация через карту
  - segtree.go: Реализация через персистентное дерево отрезков
  - test.go: Генерация тестов для бенчмарков

### Входные данные

Программа принимает входные данные в виде N прямоугольников и M точек, заданных координатами x и y.

```go
type Point struct {
	X, Y int
}

type Rectangle struct {
	LB Point // Left bottom
	RU Point // Right upper
}
```

### Решение №1

- **Алгоритмическая сложность по времени:** O(M * N)
- **Алгоритмическая сложность по памяти:** O(1)

Этот алгоритм заключается в полном переборе всех M точек и проверке принадлежности каждой из них каждому из N прямоугольников.

```go
func CheckPoint(p general.Point, r *general.Rectangles) int {
	cnt := 0
	for _, k := range *r {
		if k.Belongs(p) {
			cnt++
		}
	}
	return cnt
}
func BruteForce(ps general.Points, r general.Rectangles) {
	for _, p := range ps {
		CheckPoint(p, &r)
		
	}
}
```

### Решение №2

- **Алгоритмическая сложность по времени:** O(N^3) на построение карты и O(M * logN) на поиск ответа
- **Алгоритмическая сложность по памяти:** O(set(x) * set(y))

Этот алгоритм сначала предварительно сжимает координаты прямоугольников по обеим осям, затем строит карту и использует бинарный поиск для поиска ответа.

### Решение №3

- **Алгоритмическая сложность по времени:** O(N*logN) на построение карты и O(M * logN) на поиск ответа
- **Алгоритмическая сложность по памяти:** O(N^2)

Этот алгоритм строит персистентное дерево отрезков для оптимизации предобработки из решения №2 и ускорения поиска ответа.

### Тесты

Тестирование проводилось на данных, где число прямоугольников и точек равно 2^n, 1 <= n <= x.
### Графики

#### Время выполнения

- 
- 

#### Время на предобработку

- 
- 

#### Общее время

- 
- 

### Общий вывод

Использование алгоритма №2 (через карту) имеет смысл на малых данных, но начиная с определенного размера данных становится неэффективным из-за большой сложности. Алгоритм №3 (через персистентное дерево отрезков) наиболее эффективен на больших объемах данных, хотя требует больше памяти для предобработки. Алгоритм №1 (в лоб) подходит для небольших нагрузок, но на больших объемах данных становится неэффективным из-за своей сложности.
